-- 1. В таблице аудита найти количество попыток продвижения заказа 2520123, закончившихся ошибкой.Результат: количество попыток
-- Результат 36. Функцией like получаю сообщения о продвижении заказа, фильтрую по коду статуса сообщения.
SELECT COUNT(id_log) AS am_att
FROM fw_process_log
WHERE V_MESSAGE LIKE '%2520123%' AND n_status = 500
GROUP BY n_status
-- 2.В таблице аудита найти дату/время последней попытки продвижения заказа 2520123, закончившейся ошибкой.Результат: дата/время попытки в формате dd.mon.yyyy и номер заказа
-- Фукцией Like - отбор нужных сообщений, использование max для находения даты последней попытки. 
SELECT MAX(dt_timestamp) AS last_att, '2520123' AS num_order
FROM fw_process_log
WHERE V_MESSAGE LIKE '%2520123%' AND n_status = 500 
-- 3. Найти все номера заказов в таблице аудита, с которых начиналась загрузка порции заказов. Результат: номера заказов
-- Фильтрация по action = 12 (так как отвечает за начало загрузки). Использование distinct для отбора только уникальных заказов. 
-- Применение substr для получения номера заказа, с которого началась загрузка. 
SELECT DISTINCT substr(v_message, 35)
FROM fw_process_log
WHERE n_action = 12
-- 4. Найти количество уникальных номеров заказов в таблице аудита, с которых начиналась загрузка порции заказов.Результат: единственное число - количество заказов
-- Результат 9
SELECT COUNT(DISTINCT substr(v_message, 35)) AS count_dis_ord
FROM fw_process_log
WHERE n_action = 12
-- 5. Найти суммарную продолжительность продвижения заказов в долях секунды (доли секунды для "+000000000 00:00:00.063924000" = 63924000) в таблице аудита.Результат: единственное число
-- Использование substr для получения доли секунды (-8 - начало отсчёта символовс конца)
SELECT SUM(substr(v_message,-8)) AS sum_dur
FROM fw_process_log
WHERE n_action = 11
-- 6. Сколько было завершённых процессов продвижения заказов в таблице аудита в марте 2018. 
-- Результат: единственное число - количество завершённых процессов
SELECT COUNT(id_process) AS am_proc
FROM fw_process_log
WHERE n_action = 11 AND dt_timestamp >= to_date('2018-03-01') AND dt_timestamp <= to_date('2018-03-31')
GROUP BY id_process
-- 7. Сколько повторяющихся идентификаторов сессии есть в таблице аудита. 
-- Результат: единственное число - количество повторяющихся идентификаторов
-- В подзапросе группировка по идентификатору сессии, далее - фильтрация (отбрасываем идентификаторы, которые не повторяются). 
-- После этого в таблице остаются те идентификаторы, которые повторились. Используя count, считаю их количество. 
SELECT COUNT(rep_sid) 
FROM (SELECT COUNT(sid) AS rep_sid, sid FROM fw_process_log GROUP BY sid) 
WHERE rep_sid > 1
-- 8.Найти пользователя и последнюю дату его входа по таблице аудита для кода пользователя = 11136.Результат: дата/время и логин пользователя
SELECT os_username, MAX(dt_timestamp) AS last_si
FROM fw_process_log
WHERE id_user = 11136 
GROUP BY os_username
-- 9.Вывести количество записей в таблице аудита по месяцам. Результат: название месяца и количество записей аудита в нём
-- Используя функцию extract получаю месяц из даты, потом группирую по месяцу и считаю количество записей аудита
SELECT EXTRACT(MONTH FROM dt_timestamp) AS mon_num, COUNT(id_log) AS am_log
FROM fw_process_log
GROUP BY EXTRACT(MONTH FROM dt_timestamp)
-- 9.Вывести количество записей в таблице аудита по месяцам. Результат: название месяца и количество записей аудита в нём
-- Та же задача, но название месяца в качестве строки. 
SELECT to_char(to_date(EXTRACT(MONTH FROM dt_timestamp), 'MM'), 'month') AS mon_num, COUNT(id_log) AS am_log
FROM fw_process_log
GROUP BY EXTRACT(MONTH FROM dt_timestamp)
-- 10. Сколько записей в таблице аудита со статусом сообщения = "Ошибка" для процесса с кодом = 5 в интервале 22.02.2018 - 02.03.2018 (не включая границы). 
-- Сколько среди них с уникальным текстом сообщения. Результат: два числа - общее количество записей по условиям и количество записей с уникальным сообщением 
-- Результат 7, 1
SELECT COUNT(DISTINCT v_message) AS uniq_mess, COUNT(v_message) AS coun_mess
FROM fw_process_log
WHERE n_status = 500 AND dt_timestamp > to_date('2018-02-22 23:59:59', 'yyyy-mm-dd hh24:mi:ss') 
AND dt_timestamp < to_date('2018-03-02 00:00:00', 'yyyy-mm-dd hh24:mi:ss')
-- 11. По таблице переводов найти минимальную сумму перевода с датой поступления в систему в интервале 10:00-12:00 14 февраля 2017 при условии, что перевод должен был проходить между разными контрактами.
-- Результат: единственное число - сумма перевода
SELECT MIN(n_sum)
FROM fw_transfers
WHERE (dt_incoming >= to_date('2017-02-14 10:00:00', 'yyyy-mm-dd hh24:mi:ss')) AND
(dt_incoming <= to_date('2017-02-14 12:00:00', 'yyyy-mm-dd hh24:mi:ss')) AND (id_contract_from != id_contract_to)
-- 12. На печатном бланке для денежного перевода есть поле для комментария к денежному переводу. Максимальная длина текста в данном поле = 22 символам. 
-- Найти переводы, комментарий к которым не поместится на данном бланке. Результат: контракт (на который совершался перевод), дата перевода от оператора, количество символов комментария, 
-- которые не влезают в поле бланка. Список должен быть отсортирован по количеству "невлезающих" символов в порядке убывания.
-- Отбор тех сообщений, у которых длина превышает 22 символа. Получение строки, которая выходит за груницу, и вычисление её длины.
SELECT id_contract_to, dt_real, length(substr(v_description, 23)) AS leng_desc
FROM (SELECT id_contract_to, dt_real, v_description
FROM fw_transfers
WHERE length(v_description) >= 23)
ORDER BY leng_desc DESC
-- 13. Предоставить срез количества денежных переводов внутри контракта (контракт с которого = контракт на который) по дням. 
-- Результат: день в формате dd.mm.yyyy и количество переводов в этот день.
SELECT trans_date, COUNT(id_transfer_inst) AS coun_trans
FROM (SELECT (to_char(dt_incoming, 'dd.mm.yyyy')) AS trans_date, id_transfer_inst
FROM fw_transfers
WHERE id_contract_to = id_contract_from)
GROUP BY trans_date
